import logging
import curses
import time
from sys import stdout
from relive.io.logger import CursesHandler
import relive.cli.colors as CLR
from .screen import Screen, Window
from .repl import REPL
from relive.audio.service import AudioManager

messageWindow = None
ctrl_c_was_pressed = False
logger = logging.getLogger()


def print(message):
    if hasattr(messageWindow, 'print'):
        messageWindow.print(message)


def ctrl_c_handler(signum, frame):
    global ctrl_c_was_pressed
    ctrl_c_was_pressed = True


def ctrl_c_pressed():
    global ctrl_c_was_pressed
    if ctrl_c_was_pressed:
        ctrl_c_was_pressed = False
        return True
    else:
        return False


class TUIApp(REPL):
    file = ''

    def __init__(self, stdscr, debug=False) -> None:
        self.debug = debug
        self.screen = Screen(stdscr)
        self.screen.init_colors()
        self.initialize_screen()
        for line in self.MSG_USAGE.split('\n'):
            print(line)
        if self.debug:
            print('DEBUG mode on.')
        self.start()

    def setup_logging(self, message_window):
        logging.basicConfig(
            level=logging.INFO,
            format="%(message)s",
            handlers=[
                logging.StreamHandler(),
                CursesHandler(message_window)
            ]
        )

    def initialize_screen(self):
        global messageWindow
        maxy = curses.LINES - 1
        maxx = curses.COLS - 1

        self.header = Window(2, maxx, 0, 0, 0)
        self.header.print(self.MSG_HEADER)
        self.statusbar1 = Window(1, int(maxx/2), 1, 0, 1)
        self.statusbar2 = Window(1, int(maxx/2), 1, int(maxx/2), 1)
        self.footer = Window(1, maxx, maxy, 0, 3)
        self.footer.print('Help')
        self.messages = Window(int(maxy / 2.5), maxx, int(maxy / 2), 0, 1)
        messageWindow = self.messages

        self.console = Window(1, maxx, maxy - 3, 0, 1)
        self.console.print('>', end='')
        self.sequences = Window(int(maxy / 2.5), int(maxx / 4), 3, 0, 1)
        self.window2 = Window(
            int(maxy / 2.5), int(maxx / 4), 3, int(maxx/4), 1)
        self.setup_logging(self.messages.win)

    def draw_status(self):
        self.statusbar1.clear()
        self.statusbar2.clear()
        for item in self.get_statistics().items():
            self.statusbar1.print(
                f' {item[0]}: {item[1]} ', end='', pad=3, clr=3)
        self.statusbar2.print('StatusBar 2')

    def draw_sequences(self, sequences):
        if not sequences:
            self.sequences.print(f'BANK {self.get_value("bank", 1)}')
            self.sequences.print('')
        for sequence in sequences:
            self.sequences.print(str(sequence))

    def draw_pattern_info(self, pattern_stat):
        if not pattern_stat:
            self.window2.print(f'PATTERN {self.get_value("pattern", 1)}')
            self.window2.print('')
        for item in pattern_stat.items():
            self.window2.print(f'{item[0]}: {item[1]}')

    def get_input(self):
        self.console.print(' ')

    def draw(self, status={}, sequences=[], pattern_info={}):
        self.draw_status()
        self.draw_sequences(sequences)
        self.draw_pattern_info(pattern_info)

    def start(self):
        self.draw()
        self.messages.print('Processing...')
        self.audio = AudioManager(
            init_delay=0.2, verbose=True, debug=self.debug)
        self.audio.start()
        self.draw(
            sequences=self.audio.seq.list_sequences_in_bank(),
            pattern_info=self.audio.seq.get_pattern_info())
        self.get_input()

        self.loop()
        # while not quit:
        #     res = input(
        #         f'b{self.audio.seq.bank:02d}p{self.audio.seq.pattern:02d}> ')

    def loop(self):
        try:
            while True:
                c = 0
                code = 0
                try:
                    if ctrl_c_pressed():  # same as Ctrl+X
                        c = 24
                    else:
                        # Don't block, this allows us to refr the scr while
                        # waiting on initial messagebus connection, etc
                        # scr.timeout(1)
                        # c = scr.get_wch()
                        #    # unicode char or int for special keys
                        # if c == -1:
                        # continue
                        pass
                except curses.error:
                    continue

                if isinstance(c, int):
                    code = c
                else:
                    code = ord(c)

                # scr.timeout(-1)   # resume blocking
                if code == 27:
                    # Hitting ESC twice clears the entry line
                    hist_idx = -1
                    line = ""
                elif c == curses.KEY_RESIZE:
                    # Generated by Curses when window/screen
                    # has been resized
                    y, x = self.screen.scr.getmaxyx()
                    curses.resizeterm(y, x)
                    c = self.screen.scr.get_wch()
                elif code == 24:
                    break
                # else:
                    # logger.info(code)
                    # self.console.print(chr(code))

        finally:
            self.screen.scr.erase()
            self.screen.scr.refresh()
            messageWindow = None
            self.screen.scr = None

    def stop(self):
        self.audio.stop()
        curses.endwin()
