import logging
import curses
from sys import stdout
from relive.io.logger import CursesHandler
import relive.cli.colors as CLR
from .screen import Screen, Window
from .repl import REPL
from relive.audio.service import AudioManager

messageWindow = None
ctrl_c_was_pressed = False


def print(message):
    if hasattr(messageWindow, 'print'):
        messageWindow.print(message)


def ctrl_c_handler(signum, frame):
    global ctrl_c_was_pressed
    ctrl_c_was_pressed = True


def ctrl_c_pressed():
    global ctrl_c_was_pressed
    if ctrl_c_was_pressed:
        ctrl_c_was_pressed = False
        return True
    else:
        return False


class TUIApp(REPL):
    file = ''

    def __init__(self, stdscr, debug=False) -> None:
        self.debug = debug
        self.screen = Screen(stdscr)
        self.screen.init_colors()
        self.initialize_screen()
        if self.debug:
            print('DEBUG mode on.')
        print('h: help, x: exit, enter: previous cmd')
        print('  usage <cmd> [options]')
        print('   e.g.: pn 62 110 0 200')
        self.start()

    def setup_logging(self, message_window):
        ch = CursesHandler(message_window)
        cf = logging.Formatter('%(message)s')
        ch.setFormatter(cf)
        logger = logging.getLogger()
        logger.addHandler(ch)
        logger.setLevel(logging.INFO)

    def initialize_screen(self):
        global messageWindow
        maxy = curses.LINES - 1
        maxx = curses.COLS - 1

        self.header = Window(2, maxx, 0, 0, 0)
        self.header.print(
            'ZynTracker / zynseq interactive shell by danielwine.')
        self.statusbar1 = Window(1, int(maxx/2), 1, 0, 1)
        self.statusbar2 = Window(1, int(maxx/2), 1, int(maxx/2), 1)
        self.footer = Window(1, maxx, maxy, 0, 3)
        self.footer.print('Help')
        self.messages = Window(int(maxy / 2.5), maxx, int(maxy / 2), 0, 1)
        messageWindow = self.messages

        self.console = Window(1, maxx, maxy - 3, 0, 1)
        self.console.print('>', end='')
        self.sequences = Window(int(maxy / 2.5), int(maxx / 4), 3, 0, 1)
        self.window2 = Window(
            int(maxy / 2.5), int(maxx / 4), 3, int(maxx/4), 1)
        self.setup_logging(self.messages.win)

    def draw_status(self):
        general_stat = self.get_statistics()
        for item in general_stat.items():
            self.statusbar1.print(
                f' {item[0]}: {item[1]} ', end='', pad=3, clr=3)
        self.statusbar2.print('StatusBar 2')

    def draw_sequences(self):
        sequences = self.audio.seq.list_sequences_in_bank()
        self.sequences.print(f'BANK {self.audio.seq.bank}')
        self.sequences.print('')
        for sequence in sequences:
            self.sequences.print(str(sequence))

    def draw_pattern_info(self):
        self.window2.print(f'PATTERN {self.audio.seq.pattern}')
        self.window2.print('')
        pattern_stat = self.audio.seq.get_pattern_info()
        for item in pattern_stat.items():
            self.window2.print(f'{item[0]}: {item[1]}')

    def get_input(self):
        self.console.print(' ')

    def start(self):
        self.audio = AudioManager(
            init_delay=0.2, verbose=True, debug=self.debug)
        self.audio.start()
        self.draw_status()
        self.draw_sequences()
        self.draw_pattern_info()
        self.get_input()

        self.loop()
        # while not quit:
        #     res = input(
        #         f'b{self.audio.seq.bank:02d}p{self.audio.seq.pattern:02d}> ')

    def loop(self):
        try:
            while True:
                c = 0
                code = 0
                try:
                    if ctrl_c_pressed():  # same as Ctrl+X
                        c = 24
                    else:
                        # Don't block, this allows us to refr the scr while
                        # waiting on initial messagebus connection, etc
                        # scr.timeout(1)
                        # c = scr.get_wch()
                        #    # unicode char or int for special keys
                        # if c == -1:
                        # continue
                        pass
                except curses.error:
                    continue

                if isinstance(c, int):
                    code = c
                else:
                    code = ord(c)

                # scr.timeout(-1)   # resume blocking
                if code == 27:
                    # Hitting ESC twice clears the entry line
                    hist_idx = -1
                    line = ""
                elif c == curses.KEY_RESIZE:
                    # Generated by Curses when window/screen
                    # has been resized
                    y, x = self.screen.scr.getmaxyx()
                    curses.resizeterm(y, x)
                    c = self.screen.scr.get_wch()
                elif code == 24:
                    break

        finally:
            self.screen.scr.erase()
            self.screen.scr.refresh()
            messageWindow = None
            self.screen.scr = None

    def stop(self):
        self.audio.stop()
        curses.endwin()
